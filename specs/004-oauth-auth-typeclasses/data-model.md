# Data Model: OAuth State and Authentication Typeclasses

**Feature Branch**: `004-oauth-auth-typeclasses`
**Date**: 2025-12-11

## Entity Overview

```text
┌─────────────────────────────────────────────────────────────────┐
│                         TYPECLASSES                              │
├─────────────────────────────────────────────────────────────────┤
│  OAuthStateStore m                  AuthBackend m               │
│  ├── type OAuthStateError m         ├── type AuthBackendError m │
│  ├── type OAuthStateEnv m           └── type AuthBackendEnv m   │
│  └── methods (13 operations)                                    │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      DOMAIN NEWTYPES                             │
├─────────────────────────────────────────────────────────────────┤
│  AuthCodeId       ClientId        SessionId       UserId        │
│  AccessTokenId    RefreshTokenId  RedirectUri     Scope         │
│  CodeChallenge    Username        PlaintextPassword             │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      DOMAIN ENTITIES                             │
├─────────────────────────────────────────────────────────────────┤
│  AuthorizationCode    ClientInfo    PendingAuthorization        │
│  AuthUser             HashedPassword                            │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                         ADT TYPES                                │
├─────────────────────────────────────────────────────────────────┤
│  CodeChallengeMethod (S256 | Plain)                             │
│  GrantType (AuthorizationCode | RefreshToken | ...)             │
│  ResponseType (Code | Token)                                    │
│  ClientAuthMethod (None | ClientSecretPost | ...)               │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    IMPLEMENTATION TYPES                          │
├─────────────────────────────────────────────────────────────────┤
│  OAuthTVarEnv (in-memory)    DemoCredentialEnv (demo)           │
│  OAuthStoreError             DemoAuthError                      │
└─────────────────────────────────────────────────────────────────┘
```

## Domain Newtypes

### Identity Types

| Newtype | Wrapped Type | Purpose | Smart Constructor |
|---------|--------------|---------|-------------------|
| `AuthCodeId` | `Text` | Authorization code identifier (key) | `mkAuthCodeId` (non-empty) |
| `ClientId` | `Text` | Registered OAuth client identifier | `mkClientId` (non-empty) |
| `SessionId` | `Text` | Login session identifier (UUID) | `mkSessionId` (valid UUID) |
| `UserId` | `Text` | Authenticated user identifier | `mkUserId` (non-empty) |
| `AccessTokenId` | `Text` | Access token string (JWT) | N/A (generated by JWT library) |
| `RefreshTokenId` | `Text` | Refresh token identifier | `mkRefreshTokenId` (non-empty) |

### Value Types

| Newtype | Wrapped Type | Purpose | Smart Constructor |
|---------|--------------|---------|-------------------|
| `RedirectUri` | `URI` | Validated OAuth redirect URI | `mkRedirectUri` (valid URI, https or localhost) |
| `Scope` | `Text` | OAuth scope identifier | `mkScope` (non-empty, no whitespace) |
| `CodeChallenge` | `Text` | PKCE code challenge | `mkCodeChallenge` (base64url, 43-128 chars) |
| `Username` | `Text` | Login username | `mkUsername` (non-empty) |
| `PlaintextPassword` | `Text` | Plaintext password (never persisted) | N/A (no validation, used transiently) |

### Implementation Notes

```haskell
-- Pattern: Newtype with smart constructor
newtype ClientId = ClientId { unClientId :: Text }
  deriving (Eq, Ord, Show, Generic)
  deriving newtype (FromJSON, ToJSON, Hashable)

mkClientId :: Text -> Maybe ClientId
mkClientId t
  | Text.null t = Nothing
  | otherwise = Just (ClientId t)

-- Pattern: URI-based newtype with validation
newtype RedirectUri = RedirectUri { unRedirectUri :: URI }
  deriving (Eq, Show, Generic)

mkRedirectUri :: Text -> Maybe RedirectUri
mkRedirectUri t = do
  uri <- parseURI (Text.unpack t)
  guard (isValidRedirectUri uri)
  pure (RedirectUri uri)
  where
    isValidRedirectUri uri =
      uriScheme uri == "https:" ||
      (uriScheme uri == "http:" && isLocalhost (uriAuthority uri))
```

## Algebraic Data Types

### CodeChallengeMethod

**Purpose**: PKCE code challenge method (eliminates stringly-typed validation)

```haskell
data CodeChallengeMethod
  = S256    -- SHA256 hash (recommended)
  | Plain   -- Plaintext (legacy, discouraged)
  deriving (Eq, Show, Generic, Bounded, Enum)

instance FromJSON CodeChallengeMethod where
  parseJSON = withText "CodeChallengeMethod" $ \case
    "S256"  -> pure S256
    "plain" -> pure Plain
    other   -> fail $ "Unknown code challenge method: " <> Text.unpack other

instance ToJSON CodeChallengeMethod where
  toJSON S256  = String "S256"
  toJSON Plain = String "plain"
```

### GrantType

**Purpose**: OAuth grant type (eliminates stringly-typed validation)

```haskell
data GrantType
  = GrantAuthorizationCode  -- "authorization_code"
  | GrantRefreshToken       -- "refresh_token"
  | GrantClientCredentials  -- "client_credentials" (future)
  deriving (Eq, Show, Generic, Bounded, Enum)
```

### ResponseType

**Purpose**: OAuth response type

```haskell
data ResponseType
  = ResponseCode   -- "code" (authorization code flow)
  | ResponseToken  -- "token" (implicit flow, deprecated)
  deriving (Eq, Show, Generic, Bounded, Enum)
```

### ClientAuthMethod

**Purpose**: Client authentication method

```haskell
data ClientAuthMethod
  = AuthNone              -- "none" (public client)
  | AuthClientSecretPost  -- "client_secret_post"
  | AuthClientSecretBasic -- "client_secret_basic"
  deriving (Eq, Show, Generic, Bounded, Enum)
```

## Typeclass Definitions

### OAuthStateStore

**Purpose**: Abstract interface for OAuth 2.1 state persistence

**Associated Types**:
| Type | Purpose |
|------|---------|
| `OAuthStateError m` | Implementation-specific failure modes |
| `OAuthStateEnv m` | Implementation-specific environment/configuration |

**Methods** (using strong types):

| Method | Signature | Purpose |
|--------|-----------|---------|
| `storeAuthCode` | `AuthorizationCode -> m ()` | Store authorization code |
| `lookupAuthCode` | `AuthCodeId -> m (Maybe AuthorizationCode)` | Lookup by code (filters expired) |
| `deleteAuthCode` | `AuthCodeId -> m ()` | Delete authorization code |
| `storeAccessToken` | `AccessTokenId -> AuthUser -> m ()` | Store access token mapping |
| `lookupAccessToken` | `AccessTokenId -> m (Maybe AuthUser)` | Lookup user by access token |
| `storeRefreshToken` | `RefreshTokenId -> (ClientId, AuthUser) -> m ()` | Store refresh token |
| `lookupRefreshToken` | `RefreshTokenId -> m (Maybe (ClientId, AuthUser))` | Lookup refresh token data |
| `updateRefreshToken` | `RefreshTokenId -> (ClientId, AuthUser) -> m ()` | Update refresh token data |
| `storeClient` | `ClientId -> ClientInfo -> m ()` | Store registered client |
| `lookupClient` | `ClientId -> m (Maybe ClientInfo)` | Lookup client by ID |
| `storePendingAuth` | `SessionId -> PendingAuthorization -> m ()` | Store pending session |
| `lookupPendingAuth` | `SessionId -> m (Maybe PendingAuthorization)` | Lookup by session ID (filters expired) |
| `deletePendingAuth` | `SessionId -> m ()` | Delete pending authorization |

**Algebraic Laws** (FR-016):

1. **Round-trip**: `lookupX k` after `storeX k v` returns `Just v` (if not expired)
2. **Delete**: `lookupX k` after `deleteX k` returns `Nothing`
3. **Idempotence**: `storeX k v >> storeX k v` equivalent to `storeX k v`
4. **Overwrite**: `storeX k v2` after `storeX k v1` makes `lookupX k` return `Just v2`

### AuthBackend

**Purpose**: Abstract interface for user credential validation

**Associated Types**:
| Type | Purpose |
|------|---------|
| `AuthBackendError m` | Implementation-specific failure modes |
| `AuthBackendEnv m` | Implementation-specific environment (credential store, LDAP config, etc.) |

**Methods** (using strong types):

| Method | Signature | Purpose |
|--------|-----------|---------|
| `validateCredentials` | `Username -> PlaintextPassword -> m Bool` | Validate username/password |

## Domain Entities

### AuthorizationCode (existing, strengthened)

**Purpose**: Represents an OAuth 2.0 authorization code with PKCE

```haskell
data AuthorizationCode = AuthorizationCode
  { authCodeId :: AuthCodeId               -- Unique identifier (key)
  , authClientId :: ClientId               -- Associated client
  , authRedirectUri :: RedirectUri         -- Validated redirect URI
  , authCodeChallenge :: CodeChallenge     -- PKCE challenge
  , authCodeChallengeMethod :: CodeChallengeMethod  -- S256 or Plain (ADT)
  , authScopes :: Set Scope                -- Granted scopes (Set, not list)
  , authUserId :: UserId                   -- Authenticated user
  , authExpiry :: UTCTime                  -- Expiration timestamp
  }
  deriving (Eq, Show, Generic)
```

**Validation Rules**:
- `authCodeId` must be unique (enforced by smart constructor)
- `authExpiry` checked on lookup (filter expired)
- `authCodeChallengeMethod` is ADT (no invalid values possible)

**State Transitions**:
```text
Created (storeAuthCode) → Retrieved (lookupAuthCode) → Consumed (deleteAuthCode)
                                                    └→ Expired (filtered on lookup)
```

### ClientInfo (existing, strengthened)

**Purpose**: Represents a registered OAuth client

```haskell
data ClientInfo = ClientInfo
  { clientName :: Text                       -- Human-readable name
  , clientRedirectUris :: NonEmpty RedirectUri  -- Allowed redirect URIs (non-empty)
  , clientGrantTypes :: Set GrantType        -- Allowed grant types (Set of ADT)
  , clientResponseTypes :: Set ResponseType  -- Allowed response types (Set of ADT)
  , clientAuthMethod :: ClientAuthMethod     -- Client authentication method (ADT)
  }
  deriving (Eq, Show, Generic)
```

**Validation Rules**:
- `clientRedirectUris` is `NonEmpty` (cannot be empty by construction)
- `clientGrantTypes` and `clientResponseTypes` are `Set` of ADTs (no duplicates, no invalid values)

### PendingAuthorization (existing, strengthened)

**Purpose**: Tracks in-progress login session between /authorize and /login

```haskell
data PendingAuthorization = PendingAuthorization
  { pendingClientId :: ClientId              -- Initiating client
  , pendingRedirectUri :: RedirectUri        -- Validated redirect URI
  , pendingCodeChallenge :: CodeChallenge    -- PKCE challenge
  , pendingCodeChallengeMethod :: CodeChallengeMethod  -- Challenge method (ADT)
  , pendingScope :: Maybe (Set Scope)        -- Requested scopes
  , pendingState :: Maybe Text               -- Client state parameter (opaque)
  , pendingResource :: Maybe URI             -- Resource indicator
  , pendingCreatedAt :: UTCTime              -- Session start time (for expiry)
  }
  deriving (Eq, Show, Generic)
```

**Validation Rules**:
- Expiry: `pendingCreatedAt + loginSessionExpirySeconds`
- Filtered on lookup (expired sessions return `Nothing`)

**State Transitions**:
```text
Created (storePendingAuth) → Retrieved (lookupPendingAuth) → Approved (deletePendingAuth + storeAuthCode)
                                                          └→ Denied (deletePendingAuth only)
                                                          └→ Expired (filtered on lookup)
```

### AuthUser (existing, strengthened)

**Purpose**: Represents an authenticated user for JWT tokens

```haskell
data AuthUser = AuthUser
  { authUserId :: UserId                     -- Unique user identifier
  , authUserEmail :: Maybe EmailAddress      -- Optional email (validated type)
  , authUserName :: Maybe Text               -- Optional display name
  }
  deriving (Eq, Show, Generic)
```

**Notes**:
- `EmailAddress` from `email-validate` package (already validated)
- Derives `ToJWT` and `FromJWT` for servant-auth-server
- Stored in access/refresh token maps

### HashedPassword (existing, strengthened)

**Purpose**: Type-safe wrapper for SHA256-hashed passwords

```haskell
import Data.ByteArray (ScrubbedBytes)

newtype HashedPassword = HashedPassword
  { unHashedPassword :: ScrubbedBytes  -- From memory package
  }
  deriving (Eq, Generic)
  -- No Show instance: ScrubbedBytes doesn't have one
  -- Eq uses constant-time comparison automatically

-- Smart constructor
mkHashedPassword :: Salt -> PlaintextPassword -> HashedPassword
```

**Security Properties** (via `ScrubbedBytes`):
- Memory scrubbed on garbage collection (prevents memory dumps)
- No `Show` instance (can't accidentally log)
- `Eq` uses constant-time comparison (prevents timing attacks)
- Created only via `mkHashedPassword salt password`

**WARNING: Demo Implementation is INSECURE**

The demo uses simple SHA256 which is NOT suitable for production:
- SHA256 is too fast (billions of guesses/second)
- No memory-hardness (vulnerable to GPU/ASIC attacks)

**Production implementations MUST use:**
- **Argon2id** (recommended) - memory-hard, GPU-resistant
- **bcrypt** - time-tested, moderate security
- **PBKDF2** (minimum) - with iteration count ≥100,000

### Salt (new)

**Purpose**: Type-safe wrapper for password salt

```haskell
import Data.ByteArray (ScrubbedBytes)

newtype Salt = Salt { unSalt :: ScrubbedBytes }
  deriving (Eq, Generic)
  -- No Show instance: ScrubbedBytes doesn't have one
```

**Security Properties** (via `ScrubbedBytes`):
- Memory scrubbed on garbage collection
- No `Show` instance

### PlaintextPassword (in Auth.Backend)

**Purpose**: Transient plaintext password (never persisted)

```haskell
import Data.ByteArray (ScrubbedBytes)
import qualified Data.ByteArray.Encoding as BA
import qualified Data.Text.Encoding as T

newtype PlaintextPassword = PlaintextPassword
  { unPlaintextPassword :: ScrubbedBytes
  }
  deriving (Eq, Generic)
  -- No Show instance: ScrubbedBytes doesn't have one

-- Convert from Text (at API boundary)
mkPlaintextPassword :: Text -> PlaintextPassword
mkPlaintextPassword = PlaintextPassword . BA.convert . T.encodeUtf8
```

**Security Properties** (via `ScrubbedBytes`):
- Memory scrubbed after use
- No `Show` instance (can't accidentally log)
- Converted from `Text` only at API boundary

## Implementation Types

### OAuthTVarEnv (new)

**Purpose**: Environment for in-memory `OAuthStateStore` implementation

```haskell
data OAuthTVarEnv = OAuthTVarEnv
  { oauthStateVar :: TVar OAuthState
  , oauthExpiryConfig :: ExpiryConfig  -- Extracted from OAuthConfig
  }
```

**Notes**:
- Wraps existing `TVar OAuthState` pattern
- Includes expiry configuration for filtering expired entries
- Accessed via `HasType OAuthTVarEnv env`

### ExpiryConfig (new)

**Purpose**: Configuration for expiry-based filtering

```haskell
data ExpiryConfig = ExpiryConfig
  { authCodeExpiry :: NominalDiffTime      -- Not Int seconds
  , loginSessionExpiry :: NominalDiffTime  -- Not Int seconds
  }
```

### OAuthStoreError (new)

**Purpose**: Error type for in-memory `OAuthStateStore` implementation

```haskell
data OAuthStoreError
  = StoreUnavailable Text    -- TVar access failed (shouldn't happen with STM)
  | StoreInternalError Text  -- Unexpected internal error
  deriving (Eq, Show, Generic)
```

### DemoCredentialEnv (new)

**Purpose**: Environment for demo `AuthBackend` implementation

```haskell
data DemoCredentialEnv = DemoCredentialEnv
  { credentialStore :: CredentialStore
  }
```

### CredentialStore (existing, strengthened)

**Purpose**: In-memory credential storage

```haskell
data CredentialStore = CredentialStore
  { storeCredentials :: Map Username HashedPassword  -- Username key, not Text
  , storeSalt :: Salt                                -- Salt newtype, not Text
  }
```

### DemoAuthError (new)

**Purpose**: Error type for demo `AuthBackend` implementation

```haskell
data DemoAuthError
  = InvalidCredentials       -- Username/password mismatch
  | UserNotFound Username    -- Username not in store (typed!)
  deriving (Eq, Show, Generic)
```

## Composite Environment Type

**Purpose**: Unified environment for handlers requiring multiple typeclasses

```haskell
data AppEnv = AppEnv
  { envOAuth :: OAuthTVarEnv
  , envAuth :: DemoCredentialEnv
  , envConfig :: HTTPServerConfig
  , envTracer :: IOTracer HTTPTrace
  } deriving (Generic)
```

## Composite Error Type

**Purpose**: Unified error type for handlers requiring multiple typeclasses

```haskell
-- Updated 2025-12-15: Removed ServerErr, added fixed error types (Phase 10)
data AppError
  = OAuthStoreErr OAuthStoreError          -- Associated type (500, logged not exposed)
  | AuthBackendErr DemoAuthError           -- Associated type (401, logged not exposed)
  | ValidationErr ValidationError          -- Fixed type (400, safe to expose)
  | AuthorizationErr AuthorizationError    -- Fixed type (4xx per RFC 6749, safe to expose)
  deriving (Generic)
-- NOTE: No ServerErr constructor; ServerError translation happens at boundary only (see Phase 10)
```

## Type Migration Summary

| Old Type | New Type | Rationale |
|----------|----------|-----------|
| `Text` (auth code) | `AuthCodeId` | Prevents mixing with other text identifiers |
| `Text` (client id) | `ClientId` | Prevents mixing with other text identifiers |
| `Text` (session id) | `SessionId` | Encodes UUID constraint |
| `Text` (user id) | `UserId` | Prevents mixing with other text identifiers |
| `Text` (redirect uri) | `RedirectUri` | Encodes URI validation + https requirement |
| `Text` (scope) | `Scope` | Prevents whitespace/empty scopes |
| `Text` (code challenge) | `CodeChallenge` | Encodes base64url + length constraints |
| `Text` (code challenge method) | `CodeChallengeMethod` (ADT) | Eliminates invalid values |
| `[Text]` (scopes) | `Set Scope` | No duplicates, stronger element type |
| `[Text]` (grant types) | `Set GrantType` | No duplicates, ADT elements |
| `[Text]` (redirect uris) | `NonEmpty RedirectUri` | Non-empty, validated URIs |
| `Text` (username) | `Username` | Type safety for credential handling |
| `Text` (password) | `PlaintextPassword` (ScrubbedBytes) | Memory scrubbing, no Show, constant-time Eq |
| `Text` (hash) | `HashedPassword` (ScrubbedBytes) | Memory scrubbing, no Show, constant-time Eq |
| `Text` (salt) | `Salt` (ScrubbedBytes) | Memory scrubbing, no Show |
| `Int` (seconds) | `NominalDiffTime` | Standard Haskell time type |

## Relationships

```text
OAuthStateStore ─────────────────────────────────────────────┐
    │                                                        │
    ├── stores/retrieves ──► AuthorizationCode               │
    │       └── uses: AuthCodeId, ClientId, RedirectUri,     │
    │                 CodeChallenge, CodeChallengeMethod,    │
    │                 Set Scope, UserId, UTCTime             │
    ├── stores/retrieves ──► ClientInfo                      │
    │       └── uses: ClientId, NonEmpty RedirectUri,        │
    │                 Set GrantType, Set ResponseType,       │
    │                 ClientAuthMethod                       │
    ├── stores/retrieves ──► PendingAuthorization            │
    │       └── uses: SessionId, ClientId, RedirectUri,      │
    │                 CodeChallenge, CodeChallengeMethod,    │
    │                 Set Scope, UTCTime                     │
    └── stores/retrieves ──► AuthUser (via token maps)       │
            └── uses: UserId, EmailAddress                   │
                                                             │
AuthBackend ─────────────────────────────────────────────────┤
    │                                                        │
    └── validates using ──► Username, PlaintextPassword      │
            └── checks against: HashedPassword, Salt         │
                                                             │
AppEnv (composite) ◄─────────────────────────────────────────┘
    │
    ├── HasType OAuthTVarEnv ◄── OAuthStateStore instance
    └── HasType DemoCredentialEnv ◄── AuthBackend instance
```

---

## Phase 3 Additions: Servant Boundary Instances (mcp-51r)

**Added**: 2025-12-11 | **Context**: Type unification between HTTP.hs and OAuth.Types

### Servant Instance Requirements

All newtypes that appear in HTTP API types must implement:

| Typeclass | Purpose | Law |
|-----------|---------|-----|
| `FromHttpApiData` | Parse from URL path/query | `parseUrlPiece . toUrlPiece ≡ Right` |
| `ToHttpApiData` | Render to URL path/query | Inverse of `FromHttpApiData` |
| `FromJSON` | Parse from request body | `decode . encode ≡ Just` |
| `ToJSON` | Render to response body | Inverse of `FromJSON` |

### Instance Specifications

#### Simple Newtypes (Text wrapper)

These newtypes wrap `Text` with minimal validation (non-empty):

| Type | Validation | Error Message |
|------|------------|---------------|
| `ClientId` | Non-empty | "ClientId cannot be empty" |
| `AuthCodeId` | Non-empty | "AuthCodeId cannot be empty" |
| `SessionId` | Valid UUID format | "SessionId must be a valid UUID" |
| `UserId` | Non-empty | "UserId cannot be empty" |
| `RefreshTokenId` | Non-empty | "RefreshTokenId cannot be empty" |
| `Scope` | Non-empty, no whitespace | "Scope cannot be empty or contain whitespace" |

```haskell
-- Pattern for simple newtypes
instance FromHttpApiData ClientId where
  parseUrlPiece t
    | Text.null t = Left "ClientId cannot be empty"
    | otherwise = Right (ClientId t)

instance ToHttpApiData ClientId where
  toUrlPiece = unClientId
```

#### URI-Based Newtypes

These newtypes wrap `URI` with format and security validation:

| Type | Validation | Error Message |
|------|------------|---------------|
| `RedirectUri` | Valid URI, https OR http://localhost | "Invalid URI" / "Must be https or localhost" |

```haskell
instance FromHttpApiData RedirectUri where
  parseUrlPiece t = case parseURI (Text.unpack t) of
    Nothing -> Left "Invalid URI format"
    Just uri
      | uriScheme uri == "https:" -> Right (RedirectUri uri)
      | uriScheme uri == "http:" && isLocalhost uri -> Right (RedirectUri uri)
      | otherwise -> Left "Redirect URI must use https or http://localhost"

instance ToHttpApiData RedirectUri where
  toUrlPiece (RedirectUri uri) = Text.pack (uriToString id uri "")
```

#### ADT Types

These types are finite enumerations with string representations:

| Type | Values | JSON Representation |
|------|--------|---------------------|
| `CodeChallengeMethod` | `S256`, `Plain` | `"S256"`, `"plain"` |
| `GrantType` | `GrantAuthorizationCode`, `GrantRefreshToken`, `GrantClientCredentials` | `"authorization_code"`, `"refresh_token"`, `"client_credentials"` |
| `ResponseType` | `ResponseCode`, `ResponseToken` | `"code"`, `"token"` |
| `ClientAuthMethod` | `AuthNone`, `AuthClientSecretPost`, `AuthClientSecretBasic` | `"none"`, `"client_secret_post"`, `"client_secret_basic"` |

```haskell
instance FromHttpApiData GrantType where
  parseUrlPiece = \case
    "authorization_code" -> Right GrantAuthorizationCode
    "refresh_token" -> Right GrantRefreshToken
    "client_credentials" -> Right GrantClientCredentials
    other -> Left $ "Unknown grant type: " <> other

instance ToHttpApiData GrantType where
  toUrlPiece = \case
    GrantAuthorizationCode -> "authorization_code"
    GrantRefreshToken -> "refresh_token"
    GrantClientCredentials -> "client_credentials"
```

### Composite Type JSON Instances

For types with invariants, validation happens at parse time:

#### ClientInfo (NonEmpty RedirectUri)

```haskell
instance FromJSON ClientInfo where
  parseJSON = withObject "ClientInfo" $ \o -> do
    name <- o .: "client_name"
    uriList <- o .: "redirect_uris"
    uris <- case nonEmpty uriList of
      Nothing -> fail "redirect_uris must contain at least one URI"
      Just ne -> pure ne
    grants <- o .:? "grant_types" .!= Set.singleton GrantAuthorizationCode
    responses <- o .:? "response_types" .!= Set.singleton ResponseCode
    authMethod <- o .:? "token_endpoint_auth_method" .!= AuthNone
    pure $ ClientInfo name uris grants responses authMethod
```

### HTTP.hs Legacy vs OAuth.Types Mapping

| HTTP.hs Field (Legacy) | OAuth.Types Field (Target) | Migration Notes |
|------------------------|---------------------------|-----------------|
| `clientRedirectUris :: [Text]` | `clientRedirectUris :: NonEmpty RedirectUri` | Servant parses directly to `NonEmpty`; empty list → 400 |
| `clientGrantTypes :: [Text]` | `clientGrantTypes :: Set GrantType` | ADT parsing rejects unknown values |
| `authCode :: Text` | `authCodeId :: AuthCodeId` | Simple newtype wrap |
| `clientId :: Text` | `clientId :: ClientId` | Simple newtype wrap |
| `sessionId :: Text` | `sessionId :: SessionId` | UUID validation added |
| `pendingRedirectUri :: Text` | `pendingRedirectUri :: RedirectUri` | URI validation added |

### Handler Type Signature Evolution

```haskell
-- Legacy (HTTP.hs current)
handleClientRegistration ::
  TVar OAuthState ->
  OAuthConfig ->
  ClientRegistrationRequest ->  -- Contains [Text] redirect_uris
  Handler ClientRegistrationResponse

-- Target (after migration)
handleClientRegistration ::
  ( OAuthStateStore m
  , MonadError e m
  , AsType (OAuthStateError m) e
  ) =>
  ClientRegistrationRequest ->  -- Contains NonEmpty RedirectUri
  m ClientRegistrationResponse
```

### Arbitrary Instance Requirements

For property-based testing, all newtypes need `Arbitrary` instances that only generate valid values:

```haskell
-- test/Generators.hs additions

instance Arbitrary ClientId where
  arbitrary = ClientId <$> genNonEmptyText
  shrink (ClientId t) = ClientId <$> filter (not . Text.null) (shrink t)

instance Arbitrary RedirectUri where
  arbitrary = do
    scheme <- elements ["https://example.com/", "http://localhost:"]
    path <- listOf (elements ['a'..'z'])
    let uri = scheme ++ path
    pure $ fromJust $ mkRedirectUri (Text.pack uri)
  shrink = const []  -- Cannot shrink to invalid URIs

instance Arbitrary ClientInfo where
  arbitrary = ClientInfo
    <$> arbitrary
    <*> genNonEmptyList arbitrary  -- NonEmpty RedirectUri
    <*> arbitrary                   -- Set GrantType (via Bounded/Enum)
    <*> arbitrary                   -- Set ResponseType
    <*> arbitrary                   -- ClientAuthMethod

-- Helper
genNonEmptyText :: Gen Text
genNonEmptyText = Text.pack <$> listOf1 (elements ['a'..'z'])

genNonEmptyList :: Gen a -> Gen (NonEmpty a)
genNonEmptyList g = NE.fromList <$> listOf1 g
```

---

## Phase 10 Additions: Domain Error Types (FR-043 through FR-045)

**Added**: 2025-12-15 | **Context**: Error architecture refinement for framework-agnostic handlers

### Problem Statement

The original error design hardcoded `ServerErr ServerError` in `AppError`, coupling handlers to Servant. This prevents handler reuse in other frameworks (Yesod, CLI) and doesn't provide precise HTTP status mapping per OAuth RFC 6749.

### Fixed Error Types (Protocol-Defined)

These types are NOT associated types—they're fixed by the OAuth protocol and safe to expose to clients.

#### AuthorizationError

**Purpose**: OAuth 2.0 protocol errors per RFC 6749 Section 4.1.2.1 and 5.2

**Location**: `MCP.Server.OAuth.Types`

```haskell
-- | OAuth 2.0 authorization errors with RFC 6749 codes.
-- Fixed type (protocol-defined), safe to expose to clients.
data AuthorizationError
  = InvalidRequest Text           -- 400: Missing/invalid parameter
  | InvalidClient Text            -- 401: Client authentication failed
  | InvalidGrant Text             -- 400: Invalid code/token
  | UnauthorizedClient Text       -- 403: Client not authorized for grant type
  | UnsupportedGrantType Text     -- 400: Grant type not supported
  | InvalidScope Text             -- 400: Invalid/unknown scope
  | AccessDenied Text             -- 403: User denied authorization
  | ExpiredCode                   -- 400: Authorization code expired
  | InvalidRedirectUri Text       -- 400: Redirect URI mismatch
  | PKCEVerificationFailed        -- 400: Code verifier doesn't match challenge
  deriving (Eq, Show, Generic)

-- | Map to HTTP status and OAuth error response JSON
authorizationErrorToResponse :: AuthorizationError -> (Status, OAuthErrorResponse)
authorizationErrorToResponse = \case
  InvalidRequest msg      -> (status400, OAuthErrorResponse "invalid_request" (Just msg))
  InvalidClient msg       -> (status401, OAuthErrorResponse "invalid_client" (Just msg))
  InvalidGrant msg        -> (status400, OAuthErrorResponse "invalid_grant" (Just msg))
  UnauthorizedClient msg  -> (status403, OAuthErrorResponse "unauthorized_client" (Just msg))
  UnsupportedGrantType msg-> (status400, OAuthErrorResponse "unsupported_grant_type" (Just msg))
  InvalidScope msg        -> (status400, OAuthErrorResponse "invalid_scope" (Just msg))
  AccessDenied msg        -> (status403, OAuthErrorResponse "access_denied" (Just msg))
  ExpiredCode             -> (status400, OAuthErrorResponse "invalid_grant" (Just "Authorization code expired"))
  InvalidRedirectUri msg  -> (status400, OAuthErrorResponse "invalid_request" (Just msg))
  PKCEVerificationFailed  -> (status400, OAuthErrorResponse "invalid_grant" (Just "PKCE verification failed"))
```

#### ValidationError

**Purpose**: Semantic validation failures at handler level (distinct from parse-time 400s)

**Location**: `MCP.Server.OAuth.Types`

```haskell
-- | Semantic validation errors.
-- Distinct from FromJSON/FromHttpApiData parse errors.
-- Fixed type, safe to expose (no infrastructure secrets).
data ValidationError
  = RedirectUriMismatch ClientId RedirectUri  -- redirect_uri doesn't match registered
  | UnsupportedResponseType Text              -- response_type not supported by client
  | ClientNotRegistered ClientId              -- client_id not found
  | MissingRequiredScope Scope                -- required scope not requested
  | InvalidStateParameter Text                -- state parameter validation failed
  deriving (Eq, Show, Generic)

-- | Always maps to 400 Bad Request
validationErrorToResponse :: ValidationError -> (Status, Text)
validationErrorToResponse = \case
  RedirectUriMismatch cid _ -> (status400, "redirect_uri does not match registered URIs for " <> unClientId cid)
  UnsupportedResponseType t -> (status400, "response_type not supported: " <> t)
  ClientNotRegistered cid   -> (status400, "Client not found: " <> unClientId cid)
  MissingRequiredScope s    -> (status400, "Required scope missing: " <> unScope s)
  InvalidStateParameter msg -> (status400, "Invalid state parameter: " <> msg)
```

### Error Type Categorization

| Error Type | Kind | HTTP Status | Exposure Policy |
|------------|------|-------------|-----------------|
| `OAuthStateError m` | Associated | 500 | LOGGED, generic message to client |
| `AuthBackendError m` | Associated | 401 | LOGGED, generic message to client |
| `ValidationError` | Fixed | 400 | Safe to expose (no secrets) |
| `AuthorizationError` | Fixed | 4xx per RFC | Safe to expose (protocol-defined) |

### Boundary Translation Function

**Location**: `MCP.Server.OAuth.Boundary`

```haskell
-- | Translate domain errors to Servant ServerError.
-- Security: associated types logged, fixed types exposed.
domainErrorToServerError
  :: forall m m' e trace.
     ( MonadIO m
     , AsType (OAuthStateError m') e
     , AsType (AuthBackendError m') e
     , AsType ValidationError e
     , AsType AuthorizationError e
     )
  => IOTracer trace
  -> (OAuthBoundaryTrace -> trace)
  -> e
  -> m (Maybe ServerError)
```

### Updated Entity Overview

```text
┌─────────────────────────────────────────────────────────────────┐
│                      ERROR ARCHITECTURE                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ASSOCIATED TYPES (implementation-specific, logged not exposed) │
│  ┌───────────────────────┐  ┌───────────────────────┐          │
│  │ OAuthStateError m     │  │ AuthBackendError m    │          │
│  │ - TVar errors         │  │ - LDAP errors         │          │
│  │ - PostgreSQL errors   │  │ - DB timeout          │          │
│  │ → HTTP 500 (generic)  │  │ → HTTP 401 (generic)  │          │
│  └───────────────────────┘  └───────────────────────┘          │
│                                                                 │
│  FIXED TYPES (protocol-defined, safe to expose)                 │
│  ┌───────────────────────┐  ┌───────────────────────┐          │
│  │ ValidationError       │  │ AuthorizationError    │          │
│  │ - RedirectUriMismatch │  │ - InvalidClient       │          │
│  │ - ClientNotRegistered │  │ - InvalidGrant        │          │
│  │ → HTTP 400            │  │ → HTTP 4xx per RFC    │          │
│  └───────────────────────┘  └───────────────────────┘          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
                              │
                    domainErrorToServerError
                              │
                              ▼
                      ServerError (Servant only)
```
